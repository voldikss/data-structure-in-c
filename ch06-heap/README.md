# 二叉堆

- 完全二叉树
- 使用数组实现
- 堆序性质
  - 最大堆
  - 最小堆
- 堆操作
  - Insert: 上滤，在数组末尾新建空位，逐渐上浮到最终位置(新元素一直在堆中上浮)(平均用时 O(1), 最坏用时 O(logN))
  - DeleteMin: 下滤，删除树的根节点并在该位置建立空穴，子节点中较小的上浮，循环往复(新空位一直在下沉)。当堆中存在偶数个元素的时候，将遇到一个节点只有一个儿子的情况，这种情况要注意检测。(用时 O(logN))
  - DecreaseKey(P, delta, H): 降低在位置 P 处的关键字的值，然后调整
  - IncreaseKey(P, delta, H): 增加在位置 P 处的关键字的值，然后调整
  - Delete(P, H): 首先 DecreaseKey(P, infinite, H), 然后 DeleteMin
  - BuildHeap: 相继的多个 Insert 操作来完成(从最后一个有儿子的节点（N/2）往前开始调整，逐渐和儿子比较)，平均时间 O(N) (Insert 平均时间为 O(1)，然后乘以 N)
- 应用
  - 选择问题
  - 构造堆，执行 k 次 DeleteMin，返回最后提取的元素 O(N + k logN)
  - 维持 k 个最大元素集合 S，再对每一个后来的元素进行比较，最后返回最小值()（O(N logk)）

# d-堆

# 左式堆

- 零路径长
  - 到没有两个儿子的节点的最短路径
  - 任一节点的零路径长比它诸儿子节点的零路径长的最小值大 1
  - 左式堆中的每一个节点，左儿子的零路径长大于等于右儿子的零路径长
- 操作
  - 合并：O(logN)，递归地将具有大的根值的堆与具有小的根值的堆的右儿子合并，堆序性质不满足时交换左右儿子
  - 插入：构造一个单节点堆并进行合并
  - 删除最小值：O(logN)，除掉根得到两个堆，再将其合并

# 斜堆

- 任意 M 次操作，总的最坏运行时间为 O(M logN)
- 总是交换左右儿子

# 二项队列

- 对左式堆和斜堆的改进
- 二项队列(森林)和二项树
- 操作
  - 合并：最坏花费 O(log N)，常数时间用于两个二项树相加(CombineTrees，让大根树成为小根树的子树)，总共有 O(logN) 个二项树
  - 插入：
  - 删除最小值：O(logN)，找出含有最小值元素的树并创建队列 H' 和 H" 花费 O(logN)，合并这两个队列花费 O(logN)

# 浙大 MOOC：哈弗曼树和压缩编码

TODO
